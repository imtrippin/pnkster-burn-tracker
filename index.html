<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Token Burn Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; /* Prevent scrollbars from the canvas */
        }
        /* Custom styles for the punk pink text and glowing effect */
        .fiery-text {
            text-shadow:
                0 0 5px rgba(236, 72, 153, 0.8),
                0 0 10px rgba(219, 39, 119, 0.8),
                0 0 20px rgba(190, 24, 93, 0.8),
                0 0 40px rgba(255, 0, 122, 0.7),
                0 0 80px rgba(255, 0, 122, 0.7);
        }
        .burn-effect {
            animation: burn-glow 1.5s ease-out forwards;
        }
        @keyframes burn-glow {
            0% {
                 text-shadow:
                    0 0 5px rgba(236, 72, 153, 0.8),
                    0 0 10px rgba(219, 39, 119, 0.8),
                    0 0 20px rgba(190, 24, 93, 0.8),
                    0 0 40px rgba(255, 0, 122, 0.7);
            }
            50% {
                text-shadow:
                    0 0 20px rgba(244, 114, 182, 1),
                    0 0 40px rgba(236, 72, 153, 1),
                    0 0 60px rgba(219, 39, 119, 1),
                    0 0 100px rgba(255, 0, 122, 0.9),
                    0 0 150px rgba(255, 0, 122, 0.9);
            }
            100% {
                  text-shadow:
                    0 0 5px rgba(236, 72, 153, 0.8),
                    0 0 10px rgba(219, 39, 119, 0.8),
                    0 0 20px rgba(190, 24, 93, 0.8),
                    0 0 40px rgba(255, 0, 122, 0.7);
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <!-- Canvas for particle effects -->
    <canvas id="fire-canvas" class="absolute top-0 left-0 w-full h-full z-0"></canvas>

    <!-- Main Content -->
    <div class="relative min-h-screen flex flex-col items-center justify-center p-4 z-10">
        <div id="main-container" class="w-full max-w-4xl text-center bg-black bg-opacity-50 p-6 md:p-8 rounded-2xl border border-pink-500/30 shadow-2xl shadow-pink-500/20">
            
            <!-- Token Selector Buttons -->
            <div id="token-selector" class="flex justify-center gap-4 mb-6">
                <!-- Buttons will be dynamically inserted here -->
            </div>

            <!-- Header -->
            <header class="mb-2">
                <h1 id="token-title" class="text-4xl md:text-5xl font-bold text-pink-400 fiery-text">
                    $pnkstr burned
                </h1>
            </header>

            <!-- Burned Amount Display -->
            <main class="my-8">
                <div id="burned-amount-container" class="text-5xl sm:text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-pink-400 via-fuchsia-500 to-purple-600 transition-all duration-500">
                    <span id="burned-amount">Loading...</span>
                </div>

                <!-- Additional Stats -->
                <div class="mt-10 grid grid-cols-1 md:grid-cols-3 gap-8 text-center">
                    <div>
                        <h2 class="text-sm md:text-base text-pink-400/80 uppercase tracking-widest font-bold">Circulating Supply</h2>
                        <p id="circulating-supply" class="text-2xl md:text-3xl font-semibold text-fuchsia-300 mt-2">Loading...</p>
                    </div>
                    <div>
                        <h2 class="text-sm md:text-base text-pink-400/80 uppercase tracking-widest font-bold">% of Supply Burned</h2>
                        <p id="percentage-burned" class="text-2xl md:text-3xl font-semibold text-fuchsia-300 mt-2">Loading...</p>
                    </div>
                    <div>
                        <h2 class="text-sm md:text-base text-pink-400/80 uppercase tracking-widest font-bold">BURNED (24H)</h2>
                        <p id="burned-24h" class="text-2xl md:text-3xl font-semibold text-fuchsia-300 mt-2">Loading...</p>
                    </div>
                </div>
            </main>

            <!-- Footer / Links -->
            <footer class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-8 w-full text-sm text-center">
                <a href="https://www.punkstrategy.fun/" 
                   target="_blank" 
                   rel="noopener noreferrer" 
                   class="text-pink-500 hover:text-fuchsia-400 transition-colors duration-300 py-2">
                    punkstrategy.fun
                </a>
                <a id="etherscan-link" href="https://etherscan.io/token/0xc50673edb3a7b94e8cad8a7d4e0cd68864e33edf?a=0x000000000000000000000000000000000000dead" 
                   target="_blank" 
                   rel="noopener noreferrer" 
                   class="text-pink-500 hover:text-fuchsia-400 transition-colors duration-300 py-2">
                    Verify on Etherscan
                </a>
                <a href="https://www.nftstrategy.fun/" 
                   target="_blank" 
                   rel="noopener noreferrer" 
                   class="text-pink-500 hover:text-fuchsia-400 transition-colors duration-300 py-2">
                    nftstrategy.fun
                </a>
            </footer>
        </div>
        <div id="status-indicator" class="absolute bottom-4 right-4 flex items-center space-x-2 text-sm text-gray-500">
            <div id="status-light" class="w-3 h-3 rounded-full bg-yellow-500 animate-pulse"></div>
            <span id="status-text">Connecting...</span>
        </div>
    </div>
    
    <script>
        // --- CONFIGURATION ---
        const RPC_URL = 'https://rpc.ankr.com/eth/a5738491e6c6cf706f5fe88588fb63e12abc8b9a7076ef9bee8e2f1f8a6462a4';
        const DEAD_ADDRESS = '0x000000000000000000000000000000000000dead';
        const UPDATE_INTERVAL_MS = 20000; // 20 seconds
        const BLOCKS_IN_24_HOURS = 7200; // Approx. based on 12s block time
        const LOG_QUERY_CHUNK_SIZE = 2000; // Max blocks to query for logs at once

        const tokens = {
            pnkster: {
                name: '$pnkstr',
                contract: '0xc50673EDb3A7b94E8CAD8a7d4E0cD68864E33eDF',
                decimals: 18,
                theme: {
                    border: 'border-pink-500/30',
                    shadow: 'shadow-pink-500/20',
                    headerText: 'text-pink-400',
                    gradient: ['from-pink-400', 'via-fuchsia-500', 'to-purple-600'],
                    statTitle: 'text-pink-400/80',
                    statValue: 'text-fuchsia-300',
                    link: 'text-pink-500',
                    linkHover: 'hover:text-fuchsia-400',
                    activeButton: ['bg-pink-500', 'border-pink-400'],
                    particleColor: () => `rgba(255, ${Math.random() * 50}, ${100 + Math.random() * 100}, 1)`
                }
            },
            meebster: {
                name: '$meebstr',
                contract: '0xc9b2c00f31b210fcea1242d91307a5b1e3b2be68',
                decimals: 18,
                theme: {
                    border: 'border-blue-500/30',
                    shadow: 'shadow-blue-500/20',
                    headerText: 'text-sky-400',
                    gradient: ['from-sky-400', 'via-blue-500', 'to-indigo-600'],
                    statTitle: 'text-sky-400/80',
                    statValue: 'text-blue-300',
                    link: 'text-sky-500',
                    linkHover: 'hover:text-blue-400',
                    activeButton: ['bg-blue-500', 'border-blue-400'],
                    particleColor: () => `rgba(${Math.floor(80 + Math.random() * 50)}, ${Math.floor(120 + Math.random() * 80)}, 255, 1)`
                }
            }
        };

        // --- DOM ELEMENTS ---
        const mainContainerEl = document.getElementById('main-container');
        const burnedAmountEl = document.getElementById('burned-amount');
        const burnedAmountContainerEl = document.getElementById('burned-amount-container');
        const circulatingSupplyEl = document.getElementById('circulating-supply');
        const percentageBurnedEl = document.getElementById('percentage-burned');
        const burned24hEl = document.getElementById('burned-24h');
        const statusLightEl = document.getElementById('status-light');
        const statusTextEl = document.getElementById('status-text');
        const tokenTitleEl = document.getElementById('token-title');
        const etherscanLinkEl = document.getElementById('etherscan-link');
        const tokenSelectorContainer = document.getElementById('token-selector');

        // --- STATE ---
        let lastBurnedAmount = 0;
        let currentTokenId = 'pnkster'; // Default token

        async function fetchBurnedAmount(tokenContract, tokenDecimals) {
            const data = `0x70a08231000000000000000000000000${DEAD_ADDRESS.substring(2)}`;
            const response = await fetch(RPC_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0', id: 1, method: 'eth_call',
                    params: [{ to: tokenContract, data }, 'latest']
                }),
            });
            if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
            const json = await response.json();
            if (json.error) throw new Error(`RPC Error: ${json.error.message}`);
            const balanceBigInt = BigInt(json.result);
            return Number(balanceBigInt) / (10 ** tokenDecimals);
        }

        async function fetchTotalSupply(tokenContract, tokenDecimals) {
            const data = '0x18160ddd';
            const response = await fetch(RPC_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0', id: 2, method: 'eth_call',
                    params: [{ to: tokenContract, data }, 'latest']
                }),
            });
            if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
            const json = await response.json();
            if (json.error) throw new Error(`RPC Error: ${json.error.message}`);
            const supplyBigInt = BigInt(json.result);
            return Number(supplyBigInt) / (10 ** tokenDecimals);
        }
        
        async function fetch24hBurn(tokenContract, tokenDecimals) {
            try {
                const blockNumResponse = await fetch(RPC_URL, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', id: 3, method: 'eth_blockNumber', params: [] }),
                });
                const blockNumJson = await blockNumResponse.json();
                if (blockNumJson.error) throw new Error(`RPC Error (eth_blockNumber): ${blockNumJson.error.message}`);
                const latestBlock = parseInt(blockNumJson.result, 16);
                const startBlock = latestBlock - BLOCKS_IN_24_HOURS;
                const transferEventSignature = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                const paddedDeadAddress = `0x000000000000000000000000${DEAD_ADDRESS.substring(2)}`;
                let allLogs = [];
                for (let fromBlock = startBlock; fromBlock <= latestBlock; fromBlock += LOG_QUERY_CHUNK_SIZE) {
                    const toBlock = Math.min(fromBlock + LOG_QUERY_CHUNK_SIZE - 1, latestBlock);
                    const logsResponse = await fetch(RPC_URL, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 4, method: 'eth_getLogs',
                            params: [{
                                fromBlock: `0x${fromBlock.toString(16)}`, toBlock: `0x${toBlock.toString(16)}`, address: tokenContract,
                                topics: [ transferEventSignature, null, paddedDeadAddress ]
                            }]
                        }),
                    });
                    const logsJson = await logsResponse.json();
                    if (logsJson.error) throw new Error(`RPC Error (eth_getLogs): ${logsJson.error.message}`);
                    if (logsJson.result) { allLogs = allLogs.concat(logsJson.result); }
                }
                let totalBurned24h = BigInt(0);
                for (const log of allLogs) { totalBurned24h += BigInt(log.data); }
                return Number(totalBurned24h) / (10 ** tokenDecimals);
            } catch (error) {
                console.error("Failed to fetch 24h burn amount:", error);
                return 0;
            }
        }

        async function updateStats() {
            try {
                const activeToken = tokens[currentTokenId];
                const { contract, decimals } = activeToken;
                const [burnedAmount, totalSupply, burned24h] = await Promise.all([
                    fetchBurnedAmount(contract, decimals),
                    fetchTotalSupply(contract, decimals),
                    fetch24hBurn(contract, decimals)
                ]);
                updateDisplay(activeToken, burnedAmount, totalSupply, burned24h);
                updateStatus('Connected', 'bg-green-500');
            } catch (error) {
                console.error(`Failed to fetch stats for ${currentTokenId}:`, error);
                updateStatus('Error', 'bg-red-500');
            }
        }

        function updateDisplay(activeToken, burnedAmount, totalSupply, burned24h) {
            const circulatingSupply = totalSupply - burnedAmount;
            const percentageBurned = (burnedAmount / totalSupply) * 100;
            const formattedBurned = burnedAmount.toLocaleString('en-US', { maximumFractionDigits: 0 });
            const formattedCirculating = circulatingSupply.toLocaleString('en-US', { maximumFractionDigits: 0 });
            const formattedPercentage = `${percentageBurned.toFixed(2)}%`;
            const formattedBurned24h = burned24h.toLocaleString('en-US', { maximumFractionDigits: 0 });

            tokenTitleEl.textContent = `${activeToken.name} burned`;
            etherscanLinkEl.href = `https://etherscan.io/token/${activeToken.contract}?a=${DEAD_ADDRESS}`;
            burnedAmountEl.textContent = formattedBurned;
            circulatingSupplyEl.textContent = formattedCirculating;
            percentageBurnedEl.textContent = formattedPercentage;
            burned24hEl.textContent = formattedBurned24h;

            if (lastBurnedAmount > 0 && burnedAmount > lastBurnedAmount) {
                triggerBurnEffect();
                burnedAmountContainerEl.classList.add('burn-effect');
                setTimeout(() => burnedAmountContainerEl.classList.remove('burn-effect'), 1500);
            }
            lastBurnedAmount = burnedAmount;
        }

        function applyTheme(theme) {
            const allThemeClasses = Object.values(tokens)
                .flatMap(t => Object.values(t.theme))
                .flat()
                .filter(item => typeof item === 'string');
            
            mainContainerEl.classList.remove(...allThemeClasses);
            mainContainerEl.classList.add(theme.border, theme.shadow);
            
            tokenTitleEl.classList.remove(...allThemeClasses);
            tokenTitleEl.classList.add(theme.headerText);

            burnedAmountContainerEl.classList.remove(...allThemeClasses);
            burnedAmountContainerEl.classList.add(...theme.gradient);
            
            document.querySelectorAll('.mt-10 h2').forEach(el => {
                el.classList.remove(...allThemeClasses);
                el.classList.add(theme.statTitle);
            });
            document.querySelectorAll('.mt-10 p').forEach(el => {
                el.classList.remove(...allThemeClasses);
                el.classList.add(theme.statValue);
            });
            document.querySelectorAll('footer a').forEach(link => {
                link.classList.remove(...allThemeClasses);
                link.classList.add(theme.link, theme.linkHover);
            });
        }

        function createTokenButtons() {
            tokenSelectorContainer.innerHTML = '';
            Object.keys(tokens).forEach(tokenId => {
                const token = tokens[tokenId];
                const button = document.createElement('button');
                button.textContent = token.name;
                button.dataset.tokenId = tokenId;
                button.className = 'px-4 py-2 rounded-lg border-2 font-semibold transition-colors duration-300';
                if (tokenId === currentTokenId) {
                    button.classList.add(...token.theme.activeButton, 'text-white', 'cursor-default');
                } else {
                    button.classList.add('bg-gray-800/50', 'border-gray-600', 'hover:bg-gray-700', 'hover:border-gray-500');
                }
                button.addEventListener('click', () => switchToken(tokenId));
                tokenSelectorContainer.appendChild(button);
            });
        }

        function switchToken(newTokenId) {
            if (newTokenId === currentTokenId) return;
            currentTokenId = newTokenId;
            lastBurnedAmount = 0;
            
            applyTheme(tokens[newTokenId].theme);
            createTokenButtons();

            burnedAmountEl.textContent = 'Loading...';
            circulatingSupplyEl.textContent = 'Loading...';
            percentageBurnedEl.textContent = 'Loading...';
            burned24hEl.textContent = 'Loading...';
            updateStats();
        }
        
        function updateStatus(text, colorClass) {
            statusTextEl.textContent = text;
            statusLightEl.className = `w-3 h-3 rounded-full ${colorClass}`;
            statusLightEl.classList.toggle('animate-pulse', !colorClass.includes('green'));
        }

        // --- PARTICLE EFFECT ---
        const canvas = document.getElementById('fire-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        
        function triggerBurnEffect() {
            const particleCount = 100 + Math.random() * 50;
            for (let i = 0; i < particleCount; i++) {
                particles.push(createParticle());
            }
        }

        function createParticle() {
            const activeTheme = tokens[currentTokenId].theme;
            const x = canvas.width / 2;
            const y = canvas.height;
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 2);
            const speed = 2 + Math.random() * 5;
            return {
                x: x, y: y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                size: 2 + Math.random() * 3,
                life: 60 + Math.random() * 60, maxLife: 120,
                color: activeTheme.particleColor()
            };
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.05;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                const opacity = p.life / p.maxLife;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2, false);
                ctx.fillStyle = p.color.replace(/, 1\)$/, `, ${opacity})`);
                ctx.fill();
            }
            requestAnimationFrame(animateParticles);
        }
        
        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            createTokenButtons();
            updateStats();
            setInterval(updateStats, UPDATE_INTERVAL_MS);
            animateParticles();
        });
    </script>
    
    <!-- Vercel Analytics -->
    <script>
      window.va = window.va || function () { (window.va.q = window.va.q || []).push(arguments); };
    </script>
    <script src="/_vercel/insights/script.js"></script>
</body>
</html>


